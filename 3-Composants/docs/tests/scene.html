<!DOCTYPE html>

<html>

<head>
  <title>
    Classe de test
  </title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../docco.css" />
</head>

<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
            <div id="jump_page_wrapper">
              <div id="jump_page">
                
                  
                    <a class="source" href="../components.html">
                      components.js
                    </a>
                    
                  
                    <a class="source" href="../graphicsAPI.html">
                      graphicsAPI.js
                    </a>
                    
                  
                    <a class="source" href="../inputAPI.html">
                      inputAPI.js
                    </a>
                    
                  
                    <a class="source" href="../main.html">
                      main.js
                    </a>
                    
                  
                    <a class="source" href="../pong.html">
                      pong.js
                    </a>
                    
                  
                    <a class="source" href="../scene.html">
                      scene.js
                    </a>
                    
                  
                    <a class="source" href="../sceneObject.html">
                      sceneObject.js
                    </a>
                    
                  
                    <a class="source" href="all.html">
                      tests/all.js
                    </a>
                    
                  
                    <a class="source" href="main.html">
                      tests/main.js
                    </a>
                    
                  
                    <a class="source" href="mockComponent.html">
                      tests/mockComponent.js
                    </a>
                    
                  
                    <a class="source" href="scene.html">
                      tests/scene.js
                    </a>
                    
                  
                    <a class="source" href="sceneObject.html">
                      tests/sceneObject.js
                    </a>
                    
                  
                    <a class="source" href="../utils.html">
                      utils.js
                    </a>
                    
              </div>
            </div>
        </li>
      </ul>
      
        <ul class="sections">
          
              
                
                  <li id="section-1">
                    <div class="annotation">
                      
                        <div class="pilwrap ">
                          <a class="pilcrow" href="#section-1">&#182;</a>
                        </div>
                        
                    </div>
                    
                      <div class="content">
                        <div class='highlight'><pre>define([
  <span class="hljs-string">'chai'</span>,
  <span class="hljs-string">'components'</span>,
  <span class="hljs-string">'scene'</span>,
  <span class="hljs-string">'sceneObject'</span>,
], (
  chai,
  mockComponent,
  Scene,
  SceneObject
) =&gt; {
  <span class="hljs-string">'use strict'</span>;</pre></div>
                      </div>
                      
                  </li>
                  
                
                  <li id="section-2">
                    <div class="annotation">
                      
                        <div class="pilwrap ">
                          <a class="pilcrow" href="#section-2">&#182;</a>
                        </div>
                        <h1 id="classe-de-test">Classe de test</h1>
<p>Cette classe de test est utilisée avec <a href="https://mochajs.org/">Mocha</a>,
une infrastructure permettant d’effectuer des tests unitaires.</p>
<p>Les tests sont réalisés conjointement avec le module <a href="http://chaijs.com/">Chai</a>
qui fournit des fonctions simplifiant les assertions avec
les tests. On utilise ici les fonctions <a href="http://chaijs.com/api/bdd/">expect</a>
de Chai, par choix.</p>

                    </div>
                    
                      <div class="content">
                        <div class='highlight'><pre>
  <span class="hljs-keyword">const</span> expect = chai.expect;

  <span class="hljs-keyword">const</span> TestComponent = mockComponent.TestComponent;</pre></div>
                      </div>
                      
                  </li>
                  
                
                  <li id="section-3">
                    <div class="annotation">
                      
                        <div class="pilwrap ">
                          <a class="pilcrow" href="#section-3">&#182;</a>
                        </div>
                        <h1 id="tests-sur-la-classe-scene-">Tests sur la classe <em>Scene</em></h1>

                    </div>
                    
                      <div class="content">
                        <div class='highlight'><pre>  describe(<span class="hljs-string">'Scene'</span>, () =&gt; {</pre></div>
                      </div>
                      
                  </li>
                  
                
                  <li id="section-4">
                    <div class="annotation">
                      
                        <div class="pilwrap ">
                          <a class="pilcrow" href="#section-4">&#182;</a>
                        </div>
                        <p>On va avoir besoin de créer des scènes de test pour
la plupart des tests, on crée donc une configuration qui sera
réutilisée.</p>

                    </div>
                    
                      <div class="content">
                        <div class='highlight'><pre>    <span class="hljs-keyword">const</span> sampleScene = {
      empty: {
        components: {},
        children: {},
      },
      complex: {
        components: {
          comp1: {
            hello: <span class="hljs-string">'world'</span>
          },
          comp2: {
            foo: <span class="hljs-string">'bar'</span>
          },
        },
        children: {
          first: {
            components: {},
            children: {},
          },
          second: {
            components: {},
            children: {},
          },
        },
      },
      crossRef1: {
        components: {
          refComp1: {
            target: <span class="hljs-string">'crossRef2'</span>
          },
        },
        children: {},
      },
      crossRef2: {
        components: {
          refComp2: {
            target: <span class="hljs-string">'crossRef1'</span>
          },
        },
        children: {},
      },
    };</pre></div>
                      </div>
                      
                  </li>
                  
                
                  <li id="section-5">
                    <div class="annotation">
                      
                        <div class="pilwrap ">
                          <a class="pilcrow" href="#section-5">&#182;</a>
                        </div>
                        <p>Les noms des différents objets de la hiérarchie ci-dessus.
On s’en servira pour vérifier les itérations sur l’ensemble
des objets de la scène.</p>

                    </div>
                    
                      <div class="content">
                        <div class='highlight'><pre>    <span class="hljs-keyword">const</span> sampleSceneObjNames = [
      <span class="hljs-string">'empty'</span>,
      <span class="hljs-string">'complex'</span>,
      <span class="hljs-string">'first'</span>,
      <span class="hljs-string">'second'</span>,
      <span class="hljs-string">'crossRef1'</span>,
      <span class="hljs-string">'crossRef2'</span>,
    ];</pre></div>
                      </div>
                      
                  </li>
                  
                
                  <li id="section-6">
                    <div class="annotation">
                      
                        <div class="pilwrap ">
                          <a class="pilcrow" href="#section-6">&#182;</a>
                        </div>
                        <p>Tableau associatif qui fait le lien entre les composants
et le nom des objets qui les possèdent, pour vérifier les
itérations sur l’ensemble des composants de la scène.</p>

                    </div>
                    
                      <div class="content">
                        <div class='highlight'><pre>    <span class="hljs-keyword">const</span> sampleSceneCompMap = {
      comp1: <span class="hljs-string">'complex'</span>,
      comp2: <span class="hljs-string">'complex'</span>,
      refComp1: <span class="hljs-string">'crossRef1'</span>,
      refComp2: <span class="hljs-string">'crossRef2'</span>,
    };</pre></div>
                      </div>
                      
                  </li>
                  
                
                  <li id="section-7">
                    <div class="annotation">
                      
                        <div class="pilwrap ">
                          <a class="pilcrow" href="#section-7">&#182;</a>
                        </div>
                        <h2 id="-beforeeach-"><em>beforeEach</em></h2>
<p>Cette méthode est exécutée par Mocha avant chaque test.
On l’utilise pour nettoyer les méthodes statique témoin
de la classe de composant de test.</p>

                    </div>
                    
                      <div class="content">
                        <div class='highlight'><pre>    beforeEach(() =&gt; {
      TestComponent.onCreate = ( <span class="hljs-comment">/*comp*/</span> ) =&gt; {};
      TestComponent.onSetup = ( <span class="hljs-comment">/*comp, descr*/</span> ) =&gt; {};
      TestComponent.onDisplay = ( <span class="hljs-comment">/*comp, dT*/</span> ) =&gt; {};
      TestComponent.onUpdate = ( <span class="hljs-comment">/*comp, dT*/</span> ) =&gt; {};
    });</pre></div>
                      </div>
                      
                  </li>
                  
                
                  <li id="section-8">
                    <div class="annotation">
                      
                        <div class="pilwrap ">
                          <a class="pilcrow" href="#section-8">&#182;</a>
                        </div>
                        <h2 id="tests-unitaires">Tests unitaires</h2>
<p>On vérifie ici si on peut créer un objet simple, et si
l’objet créé est une instance de la classe de scène.</p>

                    </div>
                    
                      <div class="content">
                        <div class='highlight'><pre>    it(<span class="hljs-string">'le module peut être instancié'</span>, (done) =&gt; {
      Scene.create({})
        .then((scene) =&gt; {
          expect(scene).instanceof(Scene);
          done();
        })
        .catch((err) =&gt; {
          done(err || <span class="hljs-string">'Erreur inconnue'</span>);
        });
    });</pre></div>
                      </div>
                      
                  </li>
                  
                
                  <li id="section-9">
                    <div class="annotation">
                      
                        <div class="pilwrap ">
                          <a class="pilcrow" href="#section-9">&#182;</a>
                        </div>
                        <p>Une instance de la classe Scene devrait avoir ces méthodes
et fonctions. Ce test vérifie qu’elles existent bel et bien,
sans vérifier leur fonctionnement.</p>

                    </div>
                    
                      <div class="content">
                        <div class='highlight'><pre>    it(<span class="hljs-string">'a les méthodes requises'</span>, (done) =&gt; {
      Scene.create({})
        .then((scene) =&gt; {
          expect(scene).respondTo(<span class="hljs-string">'display'</span>);
          expect(scene).respondTo(<span class="hljs-string">'update'</span>);
          expect(scene).respondTo(<span class="hljs-string">'findObject'</span>);
          done();
        })
        .catch((err) =&gt; {
          done(err || <span class="hljs-string">'Erreur inconnue'</span>);
        });
    });</pre></div>
                      </div>
                      
                  </li>
                  
                
                  <li id="section-10">
                    <div class="annotation">
                      
                        <div class="pilwrap ">
                          <a class="pilcrow" href="#section-10">&#182;</a>
                        </div>
                        <p>Ce test vérifie si il est possible de récupérer un objet
de la scène par la méthode <code>findObject</code>. On crée une scène
contenant quelques objets et on tente de les récupérer.</p>

                    </div>
                    
                      <div class="content">
                        <div class='highlight'><pre>    it(<span class="hljs-string">'peut chercher un objet de la scène par son nom'</span>, (done) =&gt; {
      Scene.create({
          premier: {
            components: {},
            children: {},
          },
          second: {
            components: {},
            children: {},
          },
        })
        .then((scene) =&gt; {
          <span class="hljs-keyword">const</span> obj1 = scene.findObject(<span class="hljs-string">'premier'</span>);
          expect(obj1).exist;
          expect(obj1).instanceof(SceneObject);
          <span class="hljs-keyword">const</span> obj2 = scene.findObject(<span class="hljs-string">'second'</span>);
          expect(obj2).exist;
          expect(obj2).instanceof(SceneObject);
          done();
        })
        .catch((err) =&gt; {
          done(err || <span class="hljs-string">'Erreur inconnue'</span>);
        });
    });</pre></div>
                      </div>
                      
                  </li>
                  
                
                  <li id="section-11">
                    <div class="annotation">
                      
                        <div class="pilwrap ">
                          <a class="pilcrow" href="#section-11">&#182;</a>
                        </div>
                        <p>Ce test vérifie qu’il est possible de créer les objets
à partir d’une structure de description. On tente par la
suite de chercher chaque objet de la liste des objets
qui doivent exister.</p>

                    </div>
                    
                      <div class="content">
                        <div class='highlight'><pre>    it(<span class="hljs-string">'instancie les objets depuis une description'</span>, (done) =&gt; {
      Scene.create(sampleScene)
        .then((scene) =&gt; {
          sampleSceneObjNames.forEach((name) =&gt; {
            <span class="hljs-keyword">const</span> obj = scene.findObject(name);
            expect(obj).exist;
            expect(obj).instanceof(SceneObject);
          });
          done();
        })
        .catch((err) =&gt; {
          done(err || <span class="hljs-string">'Erreur inconnue'</span>);
        });
    });</pre></div>
                      </div>
                      
                  </li>
                  
                
                  <li id="section-12">
                    <div class="annotation">
                      
                        <div class="pilwrap ">
                          <a class="pilcrow" href="#section-12">&#182;</a>
                        </div>
                        <p>Lors de l’appel à la méthode <em>display</em>, la méthode <em>display</em>
de chaque composants devrait être appelée une seule fois.</p>

                    </div>
                    
                      <div class="content">
                        <div class='highlight'><pre>    it(<span class="hljs-string">'appelle une fois la méthode "display" de tous les composants'</span>, (done) =&gt; {
      <span class="hljs-keyword">const</span> calls = {};
      TestComponent.onDisplay = (comp, dT) =&gt; {
        expect(calls).not.property(comp.type);
        expect(dT).equals(<span class="hljs-number">123</span>);
        calls[comp.type] = comp;
      };

      Scene.create(sampleScene)
        .then((scene) =&gt; {
          scene.display(<span class="hljs-number">123</span>);
          <span class="hljs-built_in">Object</span>.keys(sampleSceneCompMap).forEach((compName) =&gt; {
            <span class="hljs-keyword">const</span> objName = sampleSceneCompMap[compName];
            expect(calls).property(compName);
            <span class="hljs-keyword">const</span> obj = scene.findObject(objName);
            <span class="hljs-keyword">const</span> comp = obj.getComponent(compName);
            expect(calls[compName]).equals(comp);
          });
          done();
        })
        .catch((err) =&gt; {
          done(err || <span class="hljs-string">'Erreur inconnue'</span>);
        });
    });</pre></div>
                      </div>
                      
                  </li>
                  
                
                  <li id="section-13">
                    <div class="annotation">
                      
                        <div class="pilwrap ">
                          <a class="pilcrow" href="#section-13">&#182;</a>
                        </div>
                        <p>Lors de l’appel à la méthode <em>update</em>, la méthode <em>update</em>
de chaque composants devrait être appelée une seule fois.</p>

                    </div>
                    
                      <div class="content">
                        <div class='highlight'><pre>    it(<span class="hljs-string">'appelle une fois la méthode "update" de tous les composants'</span>, (done) =&gt; {
      <span class="hljs-keyword">const</span> calls = {};
      TestComponent.onUpdate = (comp, dT) =&gt; {
        expect(calls).not.property(comp.type);
        expect(dT).equals(<span class="hljs-number">123</span>);
        calls[comp.type] = comp;
      };

      Scene.create(sampleScene)
        .then((scene) =&gt; {
          scene.update(<span class="hljs-number">123</span>);
          <span class="hljs-built_in">Object</span>.keys(sampleSceneCompMap).forEach((compName) =&gt; {
            <span class="hljs-keyword">const</span> objName = sampleSceneCompMap[compName];
            expect(calls).property(compName);
            <span class="hljs-keyword">const</span> obj = scene.findObject(objName);
            <span class="hljs-keyword">const</span> comp = obj.getComponent(compName);
            expect(calls[compName]).equals(comp);
          });
          done();
        })
        .catch((err) =&gt; {
          done(err || <span class="hljs-string">'Erreur inconnue'</span>);
        });
    });</pre></div>
                      </div>
                      
                  </li>
                  
                
                  <li id="section-14">
                    <div class="annotation">
                      
                        <div class="pilwrap ">
                          <a class="pilcrow" href="#section-14">&#182;</a>
                        </div>
                        <p>Certains composants doivent faire référence à d’autres. C’est
ce qui motive l’existence de la méthode <code>setup</code> de ceux-ci,
en plus du constructeur. Pour tester ça, on modifie la méthode
statique <em>onSetup</em> du composant de test afin qu’il tente
de récupérer des références vers d’autres objets. On s’attend
à ce que ces objets existent, même s’ils n’ont pas encore été
complètement configurés.</p>

                    </div>
                    
                      <div class="content">
                        <div class='highlight'><pre>    it(<span class="hljs-string">'gère correctement les références croisées'</span>, (done) =&gt; {
      <span class="hljs-keyword">const</span> calls = {}
      TestComponent.onSetup = (comp, descr) =&gt; {
        <span class="hljs-keyword">if</span> (!(<span class="hljs-regexp">/^refComp/</span>.test(comp.type))) {
          <span class="hljs-keyword">return</span>;
        }
        expect(calls).not.property(comp.type);
        calls[comp.type] = comp;
        <span class="hljs-keyword">const</span> refObj = comp.owner.findObjectInScene(descr.target);
        expect(refObj).exist;
        expect(refObj).instanceof(SceneObject);
      };

      Scene.create(sampleScene)
        .then((scene) =&gt; {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>; ++i) {
            <span class="hljs-keyword">const</span> compName = <span class="hljs-string">`refComp<span class="hljs-subst">${i}</span>`</span>;
            <span class="hljs-keyword">const</span> objName = <span class="hljs-string">`crossRef<span class="hljs-subst">${i}</span>`</span>;
            expect(calls).property(compName);
            <span class="hljs-keyword">const</span> obj = scene.findObject(objName);
            <span class="hljs-keyword">const</span> comp = obj.getComponent(compName);
            expect(calls[compName]).equals(comp);
          }
          done();
        })
        .catch((err) =&gt; {
          done(err || <span class="hljs-string">'Erreur inconnue'</span>);
        });
    });</pre></div>
                      </div>
                      
                  </li>
                  
                
                  <li id="section-15">
                    <div class="annotation">
                      
                        <div class="pilwrap ">
                          <a class="pilcrow" href="#section-15">&#182;</a>
                        </div>
                        <p>Les composants peuvent avoir besoin d’exécuter les étapes
de configuration de manière asynchrone, à l’aide d’une <a href="http://bluebirdjs.com/docs/why-promises.html">promesse</a>.
On doit attendre la résolution de celle-ci avant de terminer
l’initialisation de la scène. Pour valider ce comportement,
on modifie la méthode statique <em>onSetup</em> du composant de test
afin qu’il incrémente un compteur et le décrémente après un
temps d’attente. Le compteur devrait être à zéro si l’attente
a été respectée.</p>

                    </div>
                    
                      <div class="content">
                        <div class='highlight'><pre>    it(<span class="hljs-string">'attend la fin des promesses des fonctions "setup" des composants'</span>, (done) =&gt; {
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delayPromise</span>(<span class="hljs-params">ms</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve) =&gt; {
          setTimeout(resolve, ms);
        });
      }

      <span class="hljs-keyword">let</span> callsCount = <span class="hljs-number">0</span>;
      TestComponent.onSetup = (comp, descr) =&gt; {
        callsCount++;
        <span class="hljs-keyword">return</span> delayPromise(<span class="hljs-number">10</span>)
          .then(() =&gt; {
            callsCount--;
          });
      };

      Scene.create(sampleScene)
        .then(() =&gt; {
          expect(callsCount).equals(<span class="hljs-number">0</span>);
          done();
        })
        .catch((err) =&gt; {
          done(err || <span class="hljs-string">'Erreur inconnue'</span>);
        });
    });
  });
});</pre></div>
                      </div>
                      
                  </li>
                  
        </ul>
        </div>
</body>

</html>
